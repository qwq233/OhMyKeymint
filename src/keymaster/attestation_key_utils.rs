// Copyright 2021, The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Implements get_attestation_key_info which loads remote provisioned or user
//! generated attestation keys.

use crate::android::hardware::security::keymint::ErrorCode::ErrorCode;
use crate::android::hardware::security::keymint::{
    AttestationKey::AttestationKey, KeyParameter::KeyParameter,
};
use crate::android::system::keystore2::{
    Domain::Domain, KeyDescriptor::KeyDescriptor, ResponseCode::ResponseCode,
};
use crate::err;
use crate::keymaster::db::{BlobMetaData, KeyEntryLoadBits, KeyIdGuard, KeyType, KeymasterDb};
use crate::keymaster::error::KsError;
use anyhow::{Context, Result};
use x509_cert::der::{Decode, Encode};

/// KeyMint takes two different kinds of attestation keys. Remote provisioned keys
/// and those that have been generated by the user. Unfortunately, they need to be
/// handled quite differently, thus the different representations.
pub enum AttestationKeyInfo {
    RkpdProvisioned {
        attestation_key: AttestationKey,
        /// Concatenated chain of DER-encoded certificates (ending with the root).
        attestation_certs: Vec<u8>,
    },
    UserGenerated {
        key_id_guard: KeyIdGuard,
        blob: Vec<u8>,
        blob_metadata: BlobMetaData,
        issuer_subject: Vec<u8>,
    },
}

/// This function loads and, optionally, assigns the caller's remote provisioned
/// attestation key if a challenge is present. Alternatively, if `attest_key_descriptor` is given,
/// it loads the user generated attestation key from the database.
pub fn get_attest_key_info(
    _key: &KeyDescriptor,
    caller_uid: u32,
    attest_key_descriptor: Option<&KeyDescriptor>,
    _params: &[KeyParameter],
    db: &mut KeymasterDb,
) -> Result<Option<AttestationKeyInfo>> {
    match attest_key_descriptor {
        None => Ok(None),
        Some(attest_key) => get_user_generated_attestation_key(attest_key, caller_uid, db)
            .context(err!("Trying to load attest key"))
            .map(Some),
    }
}

fn get_user_generated_attestation_key(
    key: &KeyDescriptor,
    caller_uid: u32,
    db: &mut KeymasterDb,
) -> Result<AttestationKeyInfo> {
    let (key_id_guard, blob, cert, blob_metadata) =
        load_attest_key_blob_and_cert(key, caller_uid, db)
            .context(err!("Failed to load blob and cert"))?;

    let cert = x509_cert::Certificate::from_der(&cert)
        .context(err!("Failed to parse subject from certificate"))?;
    let issuer_subject = cert
        .tbs_certificate
        .subject
        .to_der()
        .context(err!("failed to DER-encode subject"))?;

    Ok(AttestationKeyInfo::UserGenerated {
        key_id_guard,
        blob,
        issuer_subject,
        blob_metadata,
    })
}

fn load_attest_key_blob_and_cert(
    key: &KeyDescriptor,
    caller_uid: u32,
    db: &mut KeymasterDb,
) -> Result<(KeyIdGuard, Vec<u8>, Vec<u8>, BlobMetaData)> {
    match key.domain {
        Domain::BLOB => Err(KsError::Km(ErrorCode::INVALID_ARGUMENT))
            .context(err!("Domain::BLOB attestation keys not supported")),
        _ => {
            let (key_id_guard, mut key_entry) = db
                .load_key_entry(key, KeyType::Client, KeyEntryLoadBits::BOTH, caller_uid)
                .context(err!("Failed to load key."))?;

            let (blob, blob_metadata) = key_entry
                .take_key_blob_info()
                .ok_or(KsError::Rc(ResponseCode::INVALID_ARGUMENT))
                .context(err!(
                    "Successfully loaded key entry, but KM blob was missing"
                ))?;
            let cert = key_entry
                .take_cert()
                .ok_or(KsError::Rc(ResponseCode::INVALID_ARGUMENT))
                .context(err!("Successfully loaded key entry, but cert was missing"))?;
            Ok((key_id_guard, blob, cert, blob_metadata))
        }
    }
}
